<pre>
  BIP: ???
  Title: Modern soft-fork deployments
  Author: ...
  Comments-Summary: No comments yet.
  Comments-URI: ???
  Status: Proposed
  Type: Informational
  Created: ???
  License: BSD-2-Clause
</pre>

==Abstract==

This document specifies a proposed change to the semantics of the 'version' field in Bitcoin blocks, allowing multiple backward-compatible changes (further called "soft forks") to be deployed in parallel. It relies on interpreting the version field as a bit vector, where each bit can be used to track an independent change. These are tallied each retarget period. Once the consensus change succeeds or fails, the bit can be reused for later changes.

==Motivation==

...

==Specification==

Each soft fork deployment is specified by the following per-chain parameters (further elaborated below):

# The '''name''' specifies a very brief description of the deployment, reasonable for use as an identifier.
# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,12}.
# The '''period''' specifies the number of blocks considered as a unit. This should be 2016 for mainnet and testnet, and 144 for regtest.
# The '''signal_height''' specifies a minimum block height at which the bit gains its meaning, and must be a multiple of '''period'''.
# The '''signal_period''' specifies how many periods the first phase of signalling lasts. May be -1 to specify "forever".
# The '''quiet_period''' specifies how many periods there are between the first phase of signalling and the second phase of signalling (which precedes mandatory activation). May be -1 to specify "forever", in which case mandatory activation will not occur.
# The '''uasf_period''' speficies ohw many periods there are for the second phase of signalling prior to mandatory activation.
# The '''threshold''' specifies the number of signally blocks in a retarget period that will cause the change to activate. This should be 1916 for mainnet (95% of 2016), 1512 for testnet (75% of 2016) and 108 for regtest (75% of 144).

REST NEEDS EDITS

===User Activated Soft Forks===

In the event that the deployment is being blocked by miners despite there otherwise being consensus in favour of its deployment, it may become a user-activated deployment in either of two ways as follows:

Implementations may provide users the option to flag that a deployment is forced, in which case if the deployment is not already locked in or activated, blocks during the final retargetting period prior to '''endheight''' that do not signal for activation will be orphaned.
This follows the approach of BIP 148.
and ensures that all nodes aware of the initial deployment attempt will enforce the deployment rules.

Alternatively, implementations may set a secondary activation height ('''secondaryheight''') at which point the rules become active unconditionally, whether or not the initial deployment attempt succeeded.
This follows the design of BIP 8, which has not been used as at the time of writing.
Note that with this approach, if the initial deployment attempt fails, only nodes that are aware of the secondary activation height will enforce the deployment's rules, and further users must achieve consensus on the value of the secondary activation height via some method not defined here.

===Selection guidelines===

The following guidelines are suggested for selecting these parameters for a soft fork:

# '''name''' must be selected such that no two softforks, concurrent or otherwise, ever use the same name.
# '''bit''' must be selected such that no two concurrent softforks use the same bit.
# '''startheight''' must be greater than zero and should be set to a future block height, approximately one month (4320 blocks) after a software release date including the soft fork.
This allows for some release delays, while preventing deployments being triggered as a result of running pre-release software.
# '''endheight''' must be greater than startheight and should usually be 2 years (104832 blocks, 52 retarget periods) after startheight.
# If defined, '''secondaryheight''' must be strictly greater than endheight, and should usually be exactly one retarget period (2016 blocks) after endheight.
# Each of '''startheight''', '''endheight''' and '''secondaryheight''' must be set to the start of a retarget period (ie, a multiple of 2016).

A later deployment using the same bit is possible as long as the startheight is after the previous one's endheight, but it is discouraged until necessary, and even then recommended to have a pause in between to detect buggy software.

===States===

With each block and soft fork, we associate a deployment state. The possible states are:

# '''DEFINED''' is the first state that each soft fork starts out as. The genesis block is by definition in this state for each deployment.
# '''STARTED''' for blocks past the startheight, but prior to the endheight.
# '''UASF''' if the user activated soft fork flag is set by the user, for blocks in the final retarget period prior to endheight
# '''LOCKED_IN''' for one retarget period after the first retarget period tht either (a) was in STARTED state, with at least threshold blocks having the associated bit set in nVersion, or (b) was in UASF state.
# '''ACTIVE''' for all blocks after the LOCKED_IN period, or at heights greater than or equal to secondaryheight.
# '''FAILED''' for all blocks past the endheight, if LOCKED_IN was not reached.

===Bit flags===

The nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number. The top bits are restricted to 001 allowing two future upgrade methods; and the next 16 bits are reserved for other uses (for compatability with BIP-320).

Signalling during the DEFINED, LOCKED_IN, ACTIVE and FAILED states is ignored.
During the STARTED state, signalling is optional and controls the state transitions.
During the UASF state, all blocks must signal.

Miners should continue setting the bit in LOCKED_IN phase so uptake is visible, though this has no effect on consensus rules.

Miners should cease setting the bit within the first two retarget periods (4032 blocks, 4 weeks) once either ACTIVE or FAILED state has been reached.

Note that if a bit is reused, the startheight for the later use should be
at least 6048 blocks (3 retarget periods) higher than the endheight
for the earlier use, to ensure that the previous deployment is either
in FAILED or ACTIVE state before the bit is reused, and that miners have had two retarget periods since activation to cease setting the bit.

===New consensus rules===

The new consensus rules for each soft fork are enforced for each block that has ACTIVE state.

===State transitions===

<img src="bip-sigsf/states.png" align="middle"></img>

The genesis block has state DEFINED for each deployment, by definition.

    State GetStateForBlock(block) {
        if (block.height == 0) {
            return DEFINED;
        }

All blocks within a retarget period have the same state.
This means that if floor(block1.height / 2016) = floor(block2.height / 2016), they are guaranteed to have the same state for every deployment.

        if ((block.height % 2016) != 0) {
            return GetStateForBlock(block.parent);
        }

Otherwise, the next state depends on the previous state:

        assert(block.height % 2016 == 0 && block.height >= 2016);
        State prev_state = GetStateForBlock(GetAncestorAtHeight(block, block.height - 2016));
        switch (prev_state) {

We remain in the initial state until either we pass the start height.

        case DEFINED:
            if (block.height == startheight) {
                return STARTED;
            }
            return DEFINED;

After a period in the STARTED or SECONDARY states, we count tally the blocks with the bit set, and transition to LOCKED_IN if the number of blocks in the past period that set the deployment bit in their version numbers is greater than the threshold (if in STARTED state).
Otherwise, we transition to SECONDARY, ENFORCED, or FAILED if the applicable height has been reached, or return the current state.

Note that a block's state never depends on its own nVersion; only on that of its ancestors.

        case STARTED:
            int count = 0;
            walk = block;
            for (i = 0; i < 2016; i++) {
                walk = walk.parent;
                if (walk.nVersion & 0xE0000000 == 0x20000000 && ((walk.nVersion >> bit) & 1)) {
                    count++;
                }
            }
            if (count >= threshold) {
                return LOCKED_IN;
            }
            if (uasf_flag && block.height == endheight - 2016) {
                return UASF;
            }
            if (block.height == endheight) {
                return FAILED;
            }
            return STARTED;

After a retarget period of UASF, we automatically transition to LOCKED_IN.

        case UASF:
            return LOCKED_IN;

After a retarget period of LOCKED_IN, we automatically transition to ACTIVE.

        case LOCKED_IN:
            return ACTIVE;

The failed state is essentially terminal, unless secondaryheight is set:

        case FAILED:
            if (secondaryheight > 0 && block.height == secondaryheight) {
                return ACTIVE;
            }
            return FAILED;

Finally, ACTIVE is a terminal state, which a deployment stays in once it has been reached.

        case ACTIVE:
            return ACTIVE;
        }
    }


'''Implementation'''
It should be noted that the states are maintained along block chain branches, but may need recomputation when a reorganization happens.

Given that the state for a specific block/deployment combination is completely determined by its ancestry before the current retarget period, it is possible to implement the mechanism above efficiently and safely by caching the resulting state of every multiple-of-2016 block, indexed by its parent.

===UASF enforcement changes===

If the UASF state is reached, blocks (or headers) that do not signal for the deployment must be orphaned.

    if (GetStateForBlock(block) == UASF) {
        if (block.nVersion & 0xE0000000 != 0x20000000 || ((block.nVersion >> bit) & 1) == 0) {
            return state.Invalid(ValidationInvalidReason::RECENT_CONSENSUS_CHANGE, false, REJECT_INVALID, "uasf", "block does not comply with uasf");
        }
    }

===getblocktemplate changes===

Deployments in UASF state must be included in the '''vbrequired''' field of the template Object.

==Support for future changes==

The mechanism described above is very generic, and variations are possible for future soft forks. Here are some ideas that can be taken into account.

'''Modified thresholds'''
The 1916 block threshold (duplicated from BIP 9 and based on in BIP 34's 95%) does not have to be maintained for eternity

'''Modified periods'''
The 2016 block period aligned with difficulty retargeting is convenient for most deployments, but it may be desirable to change it if an urgent deployment is needed (compare with BIP 91).

== Rationale ==

...

improvements to bip9: provides a way to lock in a soft-fork despite miner obstruction. uses heights instead of timestamps to make it simpler to understand. drops number of version bits to 13 (0-12) to match bip-320 (version bits above that seem to be actively used for rolling on mainnet).

improvements to bip8: allows a deployed soft-fork to fail if it doesn't achieve consensus.

expects two implementation phases, initial implementation with flagheight=0, then after 9-21 months, if activation hasn't occurred, an updated implementation setting flagheight. the SECONDARY rules ensure that nodes running the initial implementation will observe the same activation height as nodes running the updated implementation, despite not knowing the flagheight. additionally, as the only change needed is to set the flagheight value, backporting the updated implementation is trivial.

this requires devs to judge if consensus has been reached, but only after 9-21 months; and only code change dependent on devs' judgement is setting a flag day, which is easy to revert if done in error.

flagheight is restricted to being >= secondaryheight to ensure devs aren't pressured to set the flagheight until there has been plenty of time for consensus to be achieved. in the (hopefully common) case where consensus becomes obvious fairly quickly, it is optimal to set flagheight = secondaryheight, removing a decision point; however the year long secondary period allows more flexibility in the cases where consensus is not immediately apparent.

only way miners lose money is if activation does not occur in first 12 months, but consensus is achieved and a flag day is set (in which case during ENFORCED period, non-signalling blocks will be orphaned, as will signalling blocks built on non-signalling blocks). removes incentive for miners to obstruct, and provides a small disincentive to obstruct.

The failure timeout allows eventual reuse of bits even if a soft fork was
never activated, so it's clear that the new use of the bit refers to a
new BIP.  It's deliberately very coarse grained, to take into account
reasonable development and deployment delays.  There are unlikely to be
enough failed proposals to cause a bit shortage.

The fallow period at the conclusion of a soft fork attempt allows some
detection of buggy clients, and allows time for warnings and software
upgrades for successful soft forks.

==Deployments==

A living list of deployment proposals can be found [[bip-sigsf/assignments.mediawiki|here]].

==Copyright==

This BIP is licensed under the BSD 2-clause license.
