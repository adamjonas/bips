<pre>
  BIP: ???
  Title: Version bits with flag day activation
  Author: ...
  Comments-Summary: No comments yet.
  Comments-URI: ???
  Status: Proposed
  Type: Informational
  Created: 2019-02-04
  License: PD
</pre>

==Abstract==

This document specifies a proposed change to the semantics of the 'version' field in Bitcoin blocks, allowing multiple backward-compatible changes (further called "soft forks") to be deployed in parallel. It relies on interpreting the version field as a bit vector, where each bit can be used to track an independent change. These are tallied each retarget period. Once the consensus change succeeds or times out, there is a "fallow" pause after which the bit can be reused for later changes.

==Motivation==

...

==Specification==

Each soft fork deployment is specified by the following per-chain parameters (further elaborated below):

# The '''name''' specifies a very brief description of the soft fork, reasonable for use as an identifier. For deployments described in a single BIP, it is recommended to use the name "bipN" where N is the appropriate BIP number.
# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,12}.
# The '''startheight''' specifies a minimum block height at which the bit gains its meaning.
# The '''secondaryheight''' specifies the block height at which activation only occurs via unanimous signalling.
# The '''flagheight''' optionally specifies a block height at which all blocks must signal for the soft fork until lock-in is achieved.
# The '''finishheight''' specifies the height at which the deployment is considered failed, if the soft fork has not locked in.
# The '''threshold''' specifies the number of signally blocks in a retarget period that will cause the change to activate. This should be 1916 for mainnet (95% of 2016) and 1512 for testnet (75% of 2016).

===Selection guidelines===

The following guidelines are suggested for selecting these parameters for a soft fork:

# '''name''' should be selected such that no two softforks, concurrent or otherwise, ever use the same name.
# '''bit''' should be selected such that no two concurrent softforks use the same bit.
# '''startheight''' should be set to a future block height, approximately one month (4320 blocks) after a software release date including the soft fork.  This allows for some release delays, while preventing triggers as a result of parties running pre-release software.
# '''secondaryheight''' should be 1 year (52416 blocks, 26 retarget periods) after startheight.
# '''finishheight''' should be 1 year (52416 blocks, 26 retarget periods) after secondaryheight.
# '''flagheight''' must not be set until near-unanimous consensus in favour of the new rules has been observed. It may be set to any height after secondaryheight and before finishheight, but should provide sufficient time for a large majority of users to upgrade their software to recognise the flagheight. This should likely be at least three months (about 13000 blocks).
# Each of '''startheight''', '''secondaryheight''', '''finishheight''' and '''flagheight''' should be set to the start of a retarget period (ie, a multiple of 2016).

A later deployment using the same bit is possible as long as the starttime is after the previous one's finishheight, but it is discouraged until necessary, and even then recommended to have a pause in between to detect buggy software.

===States===

With each block and soft fork, we associate a deployment state. The possible states are:

# '''DEFINED''' is the first state that each soft fork starts out as. The genesis block is by definition in this state for each deployment.
# '''STARTED''' for blocks past the startheight.
# '''SECONDARY''' for blocks past the secondaryheight.
# '''ENFORCED''' for one retarget period beginning at the flagheight.
# '''LOCKED_IN''' for one retarget period after the first retarget period either (a) that was in STARTED state, with at least threshold blocks having the associated bit set in nVersion, (b) that was in SECONDARY state, with all blocks having the associated bit set in nVersion, or (c) that was in ENFORCED state.
# '''ACTIVE''' for all blocks after the LOCKED_IN period.
# '''FAILED''' for all blocks past the finishheight, if LOCKED_IN was not reached.

===Bit flags===

The nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number. The top bits are restricted to 001 allowing two future upgrade methods; and the next 16 bits are reserved for other uses (for compatability with BIP-320).

Signalling during the DEFINED, LOCKED_IN, ACTIVE and FAILED states is ignored. During the STARTED and SECONDARY states, signalling is optional and controls the state transitions. During the ENFORCED state, all blocks must signal. During the RELEASED and FAILED states, all blocks must not signal.

Miners should continue setting the bit in LOCKED_IN phase so uptake is visible, though this has no effect on consensus rules.

Miners should cease setting the bit within the first two retarget periods (4032 blocks, 4 weeks) once either ACTIVE or FAILED state has been reached.

Note that if a bit is reused, the startheight for the later use should be
at least 6048 blocks (3 retarget periods) higher than the finishheight
for the earlier use, to ensure that the previous deployment is either
in FAILED or ACTIVE state before the bit is reused.

===New consensus rules===

The new consensus rules for each soft fork are enforced for each block that has ACTIVE state.

===State transitions===

<img src="bip-sigsf/states.png" align="middle"></img>

The genesis block has state DEFINED for each deployment, by definition.

    State GetStateForBlock(block) {
        if (block.height == 0) {
            return DEFINED;
        }

All blocks within a retarget period have the same state. This means that if
floor(block1.height / 2016) = floor(block2.height / 2016), they are guaranteed to have the same state for every
deployment.

        if ((block.height % 2016) != 0) {
            return GetStateForBlock(block.parent);
        }

Otherwise, the next state depends on the previous state:

        State prev_state = GetStateForBlock(GetAncestorAtHeight(block, block.height - 2016));
        switch (prev_state) {

We remain in the initial state until either we pass the start height.

        case DEFINED:
            if (block.height == startheight) {
                return STARTED;
            }
            return DEFINED;

After a period in the STARTED or SECONDARY states, we count tally the blocks with the bit set,
and transition to LOCKED_IN if the number of blocks in the past period that set the deployment bit in their version numbers is greater than the threshold (if in STARTED state), or if all blocks in the past period set the deployment bit.
Otherwise, we transition to SECONDARY, ENFORCED, or FAILED if the applicable height has been reached, or return the current state.

Note that a block's state never depends on its own nVersion; only on that of its ancestors.

        case STARTED:
        case SECONDARY:
            int count = 0;
            walk = block;
            for (i = 0; i < 2016; i++) {
                walk = walk.parent;
                if (walk.nVersion & 0xE0000000 == 0x20000000 && (walk.nVersion >> bit) & 1 == 1) {
                    count++;
                }
            }
            if ((prev_state == STARTED && count >= threshold) || count == 2016) {
                return LOCKED_IN;
            }
            if (block.height >= finishheight) {
                return FAILED;
            }
            if (block.height >= secondaryheight) {
                if (flagheight > 0 && block.height >= flagheight) {
                    return ENFORCED;
                } else {
                    return SECONDARY;
                }
            }
            return STARTED;

After a retarget period of ENFORCED, we automatically transition to LOCKED_IN.

        case ENFORCED:
            return LOCKED_IN;

After a retarget period of LOCKED_IN, we automatically transition to ACTIVE.

        case LOCKED_IN:
            return ACTIVE;

Finally, ACTIVE and FAILED are terminal states, which a deployment stays in once they're reached.

        case ACTIVE:
            return ACTIVE;

        case FAILED:
            return FAILED;
        }
    }

'''Implementation'''
It should be noted that the states are maintained along block chain
branches, but may need recomputation when a reorganization happens.

Given that the state for a specific block/deployment combination is completely determined by its ancestry before the
current retarget period (i.e. up to and including its ancestor with height block.height - 1 - (block.height % 2016)),
it is possible to implement the mechanism above efficiently and safely by caching the resulting state of every multiple-of-2016
block, indexed by its parent.

===Warning mechanism===

To support upgrade warnings, an extra "unknown upgrade" is tracked, using the "implicit bit" mask = (block.nVersion & ~expectedVersion) != 0. Mask will be non-zero whenever an unexpected bit is set in nVersion.  Whenever LOCKED_IN for the unknown upgrade is detected, the software should warn loudly about the upcoming soft fork. It should warn even more loudly after the next retarget period (when the unknown upgrade is in the ACTIVE state).

===getblocktemplate changes===

Deployments in ENFORCED state must be included in the '''vbrequired''' field of the template Object.

==Support for future changes==

The mechanism described above is very generic, and variations are possible for future soft forks. Here are some ideas that can be taken into account.

'''Modified thresholds'''
The 1916 threshold (duplicated from BIP 9 and based on in BIP 34's 95%) does not have to be maintained for eternity, but changes should take the effect on the warning system into account. In particular, having a lock-in threshold that is incompatible with the one used for the warning system may have long-term effects, as the warning system cannot rely on a permanently detectable condition anymore.

== Rationale ==

...

improvements to bip9: provides a way to lock in a soft-fork despite miner obstruction. uses heights instead of timestamps to make it simpler to understand. drops number of version bits to 13 (0-12) to match bip-320 (version bits above that seem to be actively used for rolling on mainnet).

improvements to bip8: allows a deployed soft-fork to fail if it doesn't achieve consensus.

expects two implementation phases, initial implementation with flagheight=0, then after 9-21 months, if activation hasn't occurred, an updated implementation setting flagheight. the SECONDARY rules ensure that nodes running the initial implementation will observe the same activation height as nodes running the updated implementation, despite not knowing the flagheight. additionally, as the only change needed is to set the flagheight value, backporting the updated implementation is trivial.

this requires devs to judge if consensus has been reached, but only after 9-21 months; and only code change dependent on devs' judgement is setting a flag day, which is easy to revert if done in error.

flagheight is restricted to being >= secondaryheight to ensure devs aren't pressured to set the flagheight until there has been plenty of time for consensus to be achieved. in the (hopefully common) case where consensus becomes obvious fairly quickly, it is optimal to set flagheight = secondaryheight, removing a decision point; however the year long secondary period allows more flexibility in the cases where consensus is not immediately apparent.

only way miners lose money is if activation does not occur in first 12 months, but consensus is achieved and a flag day is set (in which case during ENFORCED period, non-signalling blocks will be orphaned, as will signalling blocks built on non-signalling blocks). removes incentive for miners to obstruct, and provides a small disincentive to obstruct.

...

The failure timeout allows eventual reuse of bits even if a soft fork was
never activated, so it's clear that the new use of the bit refers to a
new BIP.  It's deliberately very coarse grained, to take into account
reasonable development and deployment delays.  There are unlikely to be
enough failed proposals to cause a bit shortage.

The fallow period at the conclusion of a soft fork attempt allows some
detection of buggy clients, and allows time for warnings and software
upgrades for successful soft forks.

==Deployments==

A living list of deployment proposals can be found [[bip-sigsf/assignments.mediawiki|here]].

==Copyright==

This document is placed in the public domain.
