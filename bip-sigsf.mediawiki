<pre>
  BIP: ???
  Title: Conditional or Guaranteed Soft-Fork Activation
  Author: ...
  Comments-Summary: No comments yet.
  Comments-URI: ???
  Status: Proposed
  Type: Informational
  Created: ???
  License: BSD-2-Clause
</pre>

==Abstract==

This document specifies a proposed change to the conditions under which
backward-compatible consensus changes ("soft forks") are activated,
allowing activation to be coordinated either via adoption and signalling
by a supermajority of hashpower, or mandatory activation at a particular
height.

==Motivation==

The primary philosophical goal this proposal aims for is to allow improvements to be made to the consensus rules while minimising centralised decision making, whether by developers, miners or parts of industry.

The process goals this proposal aims towards are:

* Allowing proposed soft forks to fail to activate in the event of significant reasonable objections: if someone has a well-accepted, reasonable use of Bitcoin that is working today, and reasonable expects it to continue working well into the future, a soft fork that breaks that use case should not be activated.

* Prioritising high levels of adoption by nodes prior to activation: rule changes do not make sense unless nodes are enforcing the changed rules.

* Using hashpower-based enforcement to reduce the risk of chain splits or consensus divergence: because nodes may not immediately deploy new software releases due to local administrative policies, a significant minority of nodes can be expected to not enforce any rule change for an extended period after a new soft fork is proposed for activation; if a supermajority of hashpower is enforcing the soft fork rules, the likelihood of a chain split that does not comply with the soft fork rules remaining the most work chain becomes extremely low, which allows for safe, early activation of the soft fork.

* Retaining hashpower contributing to the chain even when miners are unable to enforce the new ruleset: because miners are anonymous and make substantial long-term infrastructure investments, some miners may be unable to upgrade their infrastructure in a timely manner. Where this affects many miners, the change should likely be reconsidered; but where it only affects a small proportion of miners, minimising the impact on those miners while going ahead with the change is likely the optimal outcome.

==Specification==

Each soft fork deployment has a '''name''', which is a very brief description of the deployment, that may be reasonably used as an identifier, and is common across chains.

The behaviour of each soft fork deployment is specified by the following per-chain parameters:

# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,12}.
# The '''start_height''' specifies a minimum block height at which the bit gains its meaning, and must be a multiple of '''period'''.
# The '''period''' specifies the number of blocks in a period.
# The '''primary_periods''' specifies how many periods the primary phase of signalling lasts.
# The '''quiet_periods''' specifies how many periods there are between the first phase of signalling and the second phase of signalling (which precedes mandatory activation).
# The '''secondary_periods''' speficies how many periods there are for the second phase of signalling prior to mandatory activation.
# The '''threshold''' specifies the number of signalling blocks in a period that will cause the change to activate.

Two activation modes are supported: conditional and guaranteed.

In conditional activation, the soft fork has a single primary signalling phase, beginning at the specified start height and continuing for the specified number of periods. If the threshold of signalling blocks is met in any period during the primary phase, the soft fork locks in, otherwise it fails. In this case, the quiet and secondary periods parameters are not used.

In guaranteed activation, the soft fork undergoes three phases: the primary signalling phase, a quiet phase, and the secondary signalling phase. The primary phase precisely overlaps the primary phase of conditional activation, and if the threshold is passed during the phase, the soft fork locks in occurs in exactly the same way. Otherwise, after the primary signalling phase ends, a quiet phase begins, during which signalling is ignored, and following that a secondary signalling phase begins. During the secondary signalling phase, if the threshold is passed in a particular period, the soft fork locks in then, otherwise the soft fork locks in at the end of the secondary phase. With guaranteed activation, the soft fork is not able to fail.

Implementations should always use conditional activation when the deployment attempt begins. Later releases of the implementation (particularly ones mades near to, during, or after the quiet period) may change the default to guaranteed activation only if, at that time, there are no reasonable technical objections to the proposal, and there is continued support for activation. Implementations should allow users to override the default from conditional activation to guaranteed implementation.

===Selection guidelines===

The following guidelines are suggested for selecting these parameters for a soft fork:

# '''name''' must be selected such that no two softforks, concurrent or otherwise, ever use the same name.
# '''bit''' must be selected such that no two concurrent softforks use the same bit.
# The '''period''' should be 2016 for mainnet and testnet, and 144 for regtest.
# The '''threshold''' must be between 1 and '''period''', and should be 1916 for mainnet (95% of 2016), 1512 for testnet (75% of 2016) and 108 for regtest (75% of 144).
# '''start_height''' must be greater than zero and should be set to a future block height, approximately one month (4320 blocks) after a software release date including the soft fork. This allows for some release delays, while preventing deployments being triggered as a result of running pre-release software.
# The '''primary_periods''' should be 26 (one year for mainnet and testnet)
# The '''quiet_periods''' should be 13 (six months for mainnet and testnet)
# The '''secondary_periods''' should be 52 (two years for mainnet and testnet)

A later deployment using the same bit is possible as long as its '''start_height''' is greater than the prior deployment's final height, that is '''start_height + period * (primary_periods + quiet_periods + secondary_periods + 3)''', or '''start_height + period * (primary_periods + 3)''' if it is clear that guaranteed activation is not in use, but it is discouraged until necessary, and even then recommended to have a pause in between to allow detection of buggy software.

===States===

With each block and soft fork, we associate a deployment state. The possible states are:

# '''DEFINED''' for blocks prior to '''start_height'''.
# '''PRIMARY''' for blocks during the primary signalling phase.
# '''FAILED''' for blocks after the primary signalling phase, if lock in does not occur, when the activation mode is conditional.
# '''QUIET''' for blocks during the quiet phase.
# '''SECONDARY''' for blocks during the secondary signalling phase.
# '''LOCKED_IN''' for blocks in the first period after either (a) a period of blocks in either primary or secondary signalling phases in which '''threshold''' or more blocks signalled for deployment, or (b) the end of the secondary signalling phase.
# '''ACTIVE''' for all blocks after the LOCKED_IN period.

===Bit flags===

The nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number. The top bits are restricted to 001 allowing two future upgrade methods; and the next 16 bits are reserved for other uses (for compatability with BIP-320).

Signalling during the DEFINED, QUIET, LOCKED_IN, ACTIVE and FAILED states is ignored.

During the PRIMARY and SECONDARY states, signalling is optional and controls the state transitions.

Miners should continue setting the bit in the QUIET and LOCKED_IN phases so uptake is visible, though this has no effect on consensus rules.

Miners should cease setting the bit within the first two periods once either ACTIVE or FAILED state has been reached.

===New consensus rules===

The new consensus rules for each soft fork are enforced for each block that has ACTIVE state.

===State transitions===

<img src="bip-sigsf/states.png" align="middle"></img>

===Implementation Sketch===

A block's state potentially depends on three things: the previous state, the height, and any signalling that occurred within the last period. The previous state is the first thing to reason about:

    State GetStateForBlock(const Block* block) {

        State prev_state = (block->height == 0 ? DEFINED : GetStateForBlock(block->parent));

All blocks within a retarget period have the same state, so if we're not at a period boundary, that state does not change:

        if (block->height % period != 0) {
            return prev_state;
        }

The ACTIVE and FAILED states are final:

        if (prev_state == ACTIVE || prev_state == FAILED) {
            return prev_state;
        }

The LOCKED_IN state only lasts for a single period, so since we now know we're at a period boundary, we can immediately transition to ACTIVE:

        if (prev_state == LOCKED_IN) {
            return ACTIVE;
        }

Otherwise we will transition states depending on either the height or signalling. First, if applicable, check signalling:

        if (prev_state == PRIMARY || prev_state == SECONDARY) {
            int count = 0;
            const Block* walk = block;
            for (i = 0; i < period; i++) {
                walk = walk->parent;
                if ((walk->nVersion & 0xE0000000) != 0x20000000) continue;
                if ((walk->nVersion >> bit) & 1) count++;
            }
            if (count >= threshold) return LOCKED_IN;
        }

Otherwise, we transition based on height:

        if (block->height < start_height) {
            return DEFINED;
        }

        const int periods = (block->height - start_height) / period;
        if (periods < primary_periods) {
            return PRIMARY;
        } else if (activation_mode == CONDITIONAL) {
            return FAILED;
        } else if (periods < primary_periods + quiet_periods) {
            return QUIET;
        } else if (periods < primary_periods + quiet_periods + secondary_periods) {
            return SECONDARY;
        } else {
            return LOCKED_IN;
        }

And we're done:

    } // GetStateForBlock()

It should be noted that the states are maintained along block chain branches, but may need recomputation when a reorganization happens.

Because the state for a specific block/deployment combination is completely determined by its ancestry before the current retarget period, it is possible to implement the mechanism above efficiently and safely by caching the resulting state of every block at a period boundary, indexed by its parent.

==Support for future changes==

The mechanism described above is very generic, and variations are possible for future soft forks. Here are some ideas that can be taken into account.

'''Modified thresholds'''
The 1916 block threshold (duplicated from BIP 9 and based on in BIP 34's 95%) does not have to be maintained for eternity

'''Modified periods'''
The 2016 block period (aligned with difficulty retargeting) is convenient for most deployments, but it may be desirable to change it if an urgent deployment is needed (compare with BIP 91).

== Rationale ==

Some notes to maybe expand on:

improvements to bip9:
* provides a way to lock in a soft-fork despite miner obstruction.
* uses heights instead of timestamps to make it simpler to understand.
* drops number of version bits to 13 (0-12) to match bip-320 (version bits above that seem to be actively used for rolling on mainnet)

improvements to bip8: allows a deployed soft-fork to fail if it doesn't achieve consensus.

compatible with bip148 style forced activation: being height based it's easy to predict which blocks need to signal for a soft-fork to be activated, so there does not need to be months of leeway given in case hashpower doesn't follow user wishes immediately.

this requires devs to judge if consensus has been reached, but only after 12-18 months of the code being active on mainnet; and only code change dependent on devs' judgement is switching the "uasf_enabled_by_default" boolean for the deployment from false to true, so if dev's go crazy, user's can easily fork a client to behave as they want.

for normal soft-forks that only restrict behaviour of previously non-standard transactions, miners do not risk losing money at any point, unless they deliberately mine non-standard transactions.

requiring the UASF timeframe to be set from day one, allows eventual reuse of bits even if a soft fork was never activated, so it's clear that the new use of the bit refers to a new BIP.  It's deliberately very coarse grained, to take into account reasonable development and deployment delays.  There are unlikely to be enough failed proposals to cause a bit shortage. (13 bits with a 3.5 year lifespan per bit would cope with a new soft-fork attempt every four months)

==Deployments==

A living list of deployment proposals can be found [[bip-sigsf/assignments.mediawiki|here]].

==Copyright==

This BIP is licensed under the BSD 2-clause license.
