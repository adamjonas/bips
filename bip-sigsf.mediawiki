<pre>
  BIP: ???
  Title: Modern soft-fork deployments
  Author: ...
  Comments-Summary: No comments yet.
  Comments-URI: ???
  Status: Proposed
  Type: Informational
  Created: ???
  License: BSD-2-Clause
</pre>

==Abstract==

This document specifies a proposed change to the semantics of the 'version' field in Bitcoin blocks, allowing multiple backward-compatible changes (further called "soft forks") to be deployed in parallel. It relies on interpreting the version field as a bit vector, where each bit can be used to track an independent change. These are tallied each retarget period. Once the consensus change succeeds or fails, the bit can be reused for later changes.

==Motivation==

...

==Specification==

Each soft fork deployment is specified by the following per-chain parameters (further elaborated below):

# The '''name''' specifies a very brief description of the deployment, reasonable for use as an identifier.
# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,12}.
# The '''signal_height''' specifies a minimum block height at which the bit gains its meaning, and must be a multiple of '''period'''.
# The '''signal_periods''' specifies how many periods the first phase of signalling lasts.
# The '''quiet_periods''' specifies how many periods there are between the first phase of signalling and the second phase of signalling (which precedes mandatory activation).
# The '''uasf_periods''' speficies how many periods there are for the second phase of signalling prior to mandatory activation.
# The '''period''' specifies the number of blocks in a period.
# The '''threshold''' specifies the number of signally blocks in a retarget period that will cause the change to activate.

===User Activated Soft Forks===

The initial attempt at activation relies on the '''signal_height''' and '''signal_periods''' parameters -- signalling begins when the block height reaches '''signal_height''' and continues for '''signal_periods''' periods. If during any of those periods '''threshold''' blocks or more signal for activation, the deployment becomes locked in at the beginning of the next period, and becomes active as of the following period.

If the initial attempt at activation fails, a second attempt may be undertaken treating it as a "user activated soft fork". This begins after '''quiet_periods''' periods have elapsed after the signalling period finished, and continues for '''uasf_periods''' periods. If '''threshold''' blocks or more signal for activation during this attempt, the deployment becomes locked in at the beginning of the next period, and becomes active as of the beginning of the following period. If this has not happened by the beginning of the last of the '''uasf_periods''', the deployment becomes locked in at the start of this last period, and then is active as of the first block after the '''uasf_periods''' have elapsed.

Implementations should only enable the initial attempt at activation initially, with the user activated approach only enabled either by the user manually allowing it (such as a "-uasf=deployment" command line option), or by code changes included in a later release of the software made towards the end of the initial activation signalling period, or during the quiet period.

===Selection guidelines===

The following guidelines are suggested for selecting these parameters for a soft fork:

# '''name''' must be selected such that no two softforks, concurrent or otherwise, ever use the same name.
# '''bit''' must be selected such that no two concurrent softforks use the same bit.
# The '''period''' should be 2016 for mainnet and testnet, and 144 for regtest.
# The '''threshold''' must be between 1 and '''period''', and should be 1916 for mainnet (95% of 2016), 1512 for testnet (75% of 2016) and 108 for regtest (75% of 144).
# '''signal_height''' must be greater than zero and should be set to a future block height, approximately one month (4320 blocks) after a software release date including the soft fork.
This allows for some release delays, while preventing deployments being triggered as a result of running pre-release software.
# The '''signal_periods''' should be 26 (one year for mainnet and testnet)
# The '''quiet_periods''' should be 13 (six months for mainnet and testnet)
# The '''uasf_periods''' should be 52 (two years for mainnet and testnet)

A later deployment using the same bit is possible as long as its '''signal_height''' is greater than the prior deployment's final height, that is '''signal_height + period * (signal_periods + quiet_periods + uasf_periods)''', but it is discouraged until necessary, and even then recommended to have a pause in between to allow detection of buggy software.

===States===

With each block and soft fork, we associate a deployment state. The possible states are:

# '''DEFINED''' is the first state for blocks prior to '''signal_height'''.
# '''SIGNAL''' for blocks during the initial signalling phase.
# '''FAILED''' for blocks after the initial signalling phase, if lock in does not occur, and the user-activated soft fork approach is not enabled.
# '''QUIET''' for blocks after the initial signalling phase when lock in did not occur, but prior to the user-activated signalling phase, provided the user-activated soft fork approach is enabled.
# '''UASF''' for blocks after the quiet phase.
# '''LOCKED_IN''' for one period after the first period that was either (a) in SIGNAL or UASF phase, and in which at least threshold blocks signalled for activation; or (b) after '''uasf_periods-1''' periods in UASF.
# '''ACTIVE''' for all blocks after the LOCKED_IN period.

===Bit flags===

The nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number. The top bits are restricted to 001 allowing two future upgrade methods; and the next 16 bits are reserved for other uses (for compatability with BIP-320).

Signalling during the DEFINED, QUIET, LOCKED_IN, ACTIVE and FAILED states is ignored.
During the STARTED and UASF states, signalling is optional and controls the state transitions.

Miners should continue setting the bit in the QUIET and LOCKED_IN phases so uptake is visible, though this has no effect on consensus rules.

Miners should cease setting the bit within the first two periods once either ACTIVE or FAILED state has been reached.

===New consensus rules===

The new consensus rules for each soft fork are enforced for each block that has ACTIVE state.

===State transitions===

<img src="bip-sigsf/states.png" align="middle"></img>

The genesis block has state DEFINED for each deployment, by definition.

    State GetStateForBlock(block) {
        if (block.height < start_height) {
            return DEFINED;
        }

All blocks within a retarget period have the same state.
This means that if floor(block1.height / period) = floor(block2.height / period), they are guaranteed to have the same state for every deployment.

        if (block.height % period != 0) {
            return GetStateForBlock(block.parent);
        }

But it depends on what the previous state was:

        State prev_state = (block.height == 0 ? DEFINED : GetStateForBlock(GetAncestorAtHeight(block, block.height - period)));

        switch (prev_state) {

If the previous state was a final state, then we stay in it:

        case ACTIVE:
        case FAILED:
            return prev_state;

If the previous state was locked in, the new state is always ACTIVE:

        case LOCKED_IN:
            return ACTIVE;

If the previous state allowed signalling, that might get us to locked in, but if not, then our state is dictated entirely by our height.

        case SIGNAL:
        case UASF:
            int count = 0;
            walk = block;
            for (i = 0; i < period; i++) {
                walk = walk.parent;
                if (walk.nVersion & 0xE0000000 == 0x20000000 && ((walk.nVersion >> bit) & 1)) {
                    count++;
                }
            }
            if (count >= threshold) return LOCKED_IN;
            // fall through

        case DEFINED:
        case QUIET:
        {
            int periods = (block.height - start_height) / period;
            if (periods < signal_periods) {
                return SIGNAL;
            } else if (periods < signal_periods + quiet_periods) {
                return QUIET;
            } else if (periods < signal_periods + quiet_periods + uasf_periods - 1) {
                return UASF;
            } else if (periods < signal_periods + quiet_periods + uasf_periods) {
                return LOCKED_IN;
            } else {
                return ACTIVE;
            }
        }


'''Implementation'''
It should be noted that the states are maintained along block chain branches, but may need recomputation when a reorganization happens.

Given that the state for a specific block/deployment combination is completely determined by its ancestry before the current retarget period, it is possible to implement the mechanism above efficiently and safely by caching the resulting state of every multiple-of-2016 block, indexed by its parent.

==Support for future changes==

The mechanism described above is very generic, and variations are possible for future soft forks. Here are some ideas that can be taken into account.

'''Modified thresholds'''
The 1916 block threshold (duplicated from BIP 9 and based on in BIP 34's 95%) does not have to be maintained for eternity

'''Modified periods'''
The 2016 block period aligned with difficulty retargeting is convenient for most deployments, but it may be desirable to change it if an urgent deployment is needed (compare with BIP 91).

== Rationale ==

...

improvements to bip9: provides a way to lock in a soft-fork despite miner obstruction. uses heights instead of timestamps to make it simpler to understand. drops number of version bits to 13 (0-12) to match bip-320 (version bits above that seem to be actively used for rolling on mainnet).

improvements to bip8: allows a deployed soft-fork to fail if it doesn't achieve consensus.

compatible with bip148 style forced activation: being height based it's easy to predict which blocks need to signal for a soft-fork to be activated, so there does not need to be months of leeway given in case hashpower doesn't follow user wishes immediately.

this requires devs to judge if consensus has been reached, but only after 12-18 months of the code being active on mainnet; and only code change dependent on devs' judgement is switching the "uasf_enabled_by_default" boolean for the deployment from false to true, so if dev's go crazy, user's can easily fork a client to behave as they want.

for normal soft-forks that only restrict behaviour of previously non-standard transactions, miners do not risk losing money at any point, unless the deliberately mine non-standard transactions.

requiring the UASF timeframe to be set from day one, allows eventual reuse of bits even if a soft fork was
never activated, so it's clear that the new use of the bit refers to a
new BIP.  It's deliberately very coarse grained, to take into account
reasonable development and deployment delays.  There are unlikely to be
enough failed proposals to cause a bit shortage. (13 bits with a 3.5 year lifespan per bit would cope with a new soft-fork attempt every four months)

==Deployments==

A living list of deployment proposals can be found [[bip-sigsf/assignments.mediawiki|here]].

==Copyright==

This BIP is licensed under the BSD 2-clause license.
